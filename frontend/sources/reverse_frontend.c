#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <stdbool.h>

#include "tree.h"
#include "logger.h"
#include "reverse_frontend.h"
#include "frontend.h"

static void printCodeFromTree(const char * out_file_name, tree_context_t * context, node_t * root);

static void printCodeFromTreeRecursive(FILE * out_file, tree_context_t * context, node_t * node, bool need_tabs);

static void printTabs(FILE * out_file, size_t tabs_num);

static void printFuncArgs(FILE * out_file, tree_context_t * context, node_t * start_node);

static void printBlock(FILE * out_file, tree_context_t * context, node_t * node);

void reverseFrontendRun(const char * in_file_name, const char * out_file_name)
{
    fe_context_t fe = frontendInit(MAX_TOKEN_NUM);

    tree_context_t tr = {};         //TODO: GET RID OF THAT
    tr.cur_node = fe.cur_node;
    tr.ids = fe.ids;
    tr.id_size = fe.id_size;

    node_t * tree = readTreeFromIR(&tr, in_file_name);
    treeDumpGraph(&tr, tree, LOG_FOLDER_NAME);

    printCodeFromTree(out_file_name, &tr, tree);

    frontendDump(&fe);

    frontendDtor(&fe);
}

void printCodeFromTree(const char * out_file_name, tree_context_t * context, node_t * root)
{
    assert(out_file_name);
    assert(root);
    assert(context);

    FILE * out_file = fopen(out_file_name, "w");

    fprintf(out_file, "#AUTOGENERATED CODE#\n");
    printCodeFromTreeRecursive(out_file, context, root, true);

    fclose(out_file);
}

// variable for tabs
static size_t tab_num = 0;

static void printCodeFromTreeRecursive(FILE * out_file, tree_context_t * context, node_t * node, bool need_tabs)
{
    assert(out_file);
    assert(context);

    if (node == NULL)
        return;

    if (node->type == NUM){
        fprintf(out_file, "%lg", node->val.number);
        return;
    }

    if (node->type == IDR){
        fprintf(out_file, "%s", context->ids[node->val.id].name);
        return;
    }

    // if (...type == OPR)

    if (need_tabs)
        printTabs(out_file, tab_num);

    enum oper op_num = node->val.op;
    switch(op_num){
        case SEP:
            printCodeFromTreeRecursive(out_file, context, node->left, false);
            fprintf(out_file, ";\n");

            printCodeFromTreeRecursive(out_file, context, node->right, true);

            break;

        case IN: case OUT: case COS: case SIN: case LN: case TAN: case SQRT:
            fprintf(out_file, "%s(", opers[op_num].name);
            printCodeFromTreeRecursive(out_file, context, node->left, false);
            fprintf(out_file, ")");

            break;

        case ASSIGN:
            printCodeFromTreeRecursive(out_file, context, node->left, false);
            fprintf(out_file, " %s ", opers[op_num].name);
            printCodeFromTreeRecursive(out_file, context, node->right, false);

            break;

        case ADD: case SUB: case MUL: case DIV:
        case LESS: case LESS_EQ: case EQUAL: case N_EQUAL: case GREATER: case GREATER_EQ:
            // TODO: decrease number of brackets
            fprintf(out_file, "(");
            printCodeFromTreeRecursive(out_file, context, node->left, false);

            fprintf(out_file, " %s ", opers[op_num].name);

            printCodeFromTreeRecursive(out_file, context, node->right, false);
            fprintf(out_file, ")");

            break;

        case IF: case WHILE: {
            fprintf(out_file, "%s (", opers[op_num].name);
            printCodeFromTreeRecursive(out_file, context, node->left, false);
            fprintf(out_file, ")\n");

            bool have_else = node->right->type == OPR && node->right->val.op == IF_ELSE;
            node_t * if_body_node = NULL;

            // if we are having else, IF body is on the left of IF_ELSE node
            if (have_else)
                if_body_node = node->right->left;
            else
                if_body_node = node->right;

            printBlock(out_file, context, if_body_node);

            // printing ELSE if we have it
            if (have_else){
                fprintf(out_file, "\n");

                printTabs(out_file, tab_num);
                fprintf(out_file, "else\n");

                printBlock(out_file, context, node->right->right);
            }

            break;
        }

        case CALL: {
            // getting function name (left node)
            const char * func_name = context->ids[node->left->val.id].name;

            fprintf(out_file, "%s(", func_name);

            // on the right of the CALL we have arg list (if args presented)
            printFuncArgs(out_file, context, node->right);

            fprintf(out_file, ")");

            break;
        }

        case FUNC_DECL: {
            // FUNC_HEADER node on the left
            node_t * func_header = node->left;

            const char * func_name = context->ids[func_header->left->val.id].name;

            fprintf(out_file, "%s %s(", opers[FUNC_DECL].name, func_name);

            printFuncArgs(out_file, context, func_header->right);

            fprintf(out_file, ")\n");

            printBlock(out_file, context, node->right);

            break;
        }

        case VAR_DECL: {
            const char * var_name = context->ids[node->left->val.id].name;

            fprintf(out_file, "%s %s", opers[VAR_DECL].name, var_name);

            break;
        }

        case RETURN:
            fprintf(out_file, "return ");
            printCodeFromTreeRecursive(out_file, context, node->left, false);

            break;

        default:
            fprintf(stderr, "cannot generate it (%d)\n", node->val.op);
            break;
    }
}

static void printIf(FILE * out_file, tree_context_t * context, node_t * node)
{
    assert(out_file);
    assert(context);
}

static void printBlock(FILE * out_file, tree_context_t * context, node_t * node)
{
    assert(out_file);
    assert(context);

    printTabs(out_file, tab_num);
    fprintf(out_file, "%s\n", opers[BEGIN].name);
    tab_num++;

    // printing what inside of the block
    printCodeFromTreeRecursive(out_file, context, node, true);

    tab_num--;
    printTabs(out_file, tab_num);
    fprintf(out_file, "%s", opers[ENDING].name);
}

static void printFuncArgs(FILE * out_file, tree_context_t * context, node_t * node)
{
    assert(out_file);
    assert(context);

    if (node == NULL)
        return;

    node_t * arg_node = node;

    if (node->type == OPR && node->val.op == ARG_SEP){
        printFuncArgs(out_file, context, node->left);

        fprintf(out_file, ", ");

        printFuncArgs(out_file, context, node->right);

        return;
    }

    // else
    printCodeFromTreeRecursive(out_file, context, node, false);
}

static void printTabs(FILE * out_file, size_t tabs_num)
{
    assert(out_file);

    for (size_t tab_index = 0; tab_index < tabs_num; tab_index++){
        fputc('\t', out_file);
    }
}
